## Overview  

This document organizes the Shapes data fields that exist so far, sketches some data fields that don't yet exist, and lists various application tasks to populate and use those data fields.

The data is organized into two separate databases. In general, `shapes.sqlite` contains the data required by user-facing Shapes applications, and `shapes_experiments.sqlite` contains the data generated by those applications. Some data in `shapes.sqlite` is informed by analyzing data in `shapes_experiments.sqlite`.


**Shapes Application Data**  
`shapes.sqlite`
- [Source Data](#source-data)  
- [Song Data](#song-data)
- [Source-Song Join Table](#source-song-join-table)
- [Multi-song Videos](#multi-song-videos)   
- [Manual Video Metadata](#manual-video-metadata)  
- [Video Zoom](#video-zoom)  
- [Automatic Video Metadata](#automatic-video-metadata)  
- [Key Level Context](#key-level-context)  
- [Chord Level Context](#chord-level-context)  
- [Song Preferences](#song-preferences)  
- [Audio Data](#audio-data)  
- [Default Instrument Settings](#default-instrument-settings)  
- [Original iPad App Instrument Settings](#original-ipad-app-instrument-settings)  

**Shapes User and Experiment Data**  
`shapes_experiments.sqlite`
- [Session Data](#session-data)  
- [User Key Level Context](#user-key-level-context)  
- [User Chord Level Context](#user-chord-level-context)  
- [User Comments](#user-comments)  
- [User Song Favorites](#user-song-favorites)  
- [User Song Rating](#user-song-rating)  
- [Event Data](#event-data)  

**Application Tasks**
- [Scrape Songs](#scrape-songs)  
- [Find and Remove Duplicate Songs](#find-and-remove-duplicate-songs)  
- [Add YouTube Video IDs](#add-youtube-video-ids)  
- [Crawl YouTube Metadata](#crawl-youtube-metadata)  
- [Retrieve One-Time YouTube Metadata](#retrieve-one-time-youtube-metadata)  
- [Download Music Video Files to the server](#download-music-video-files-to-the-server)
- [Input Manual Video Metadata](#input-manual-video-metadata)
- [Play Videos as fullscreen background](#play-videos-as-fullscreen-background)
- [Play a Browser Instrument over Video Background](#play-a-browser-instrument-over-video-background)
- [Automatically Analyze Tuning and Key Context](#automatically-analyze-tuning-and-key-context)  
- ...


---
## Shapes Application Data
This is the data required by user-facing Shapes applications.


### Source Data  
The `source` model describes the source (e.g. a chart, playlist, article, etc.) from which songs were added to the database.

source ||
--- | --- |
`id` | `integer`<br> The `id` for the source. |
`parent_entity` | `varchar`<br> The organization, publication, institution, etc. from which the source originated. |
`parent_stream` | `varchar`<br> The recurring series, feed, channel, etc. where the source was published. |
`instance_name` | `varchar`<br> The published instance of the source. |
`publication_date` | `datetime`<br> The publication date displayed on the source (this is not necessarily the actual release date). |
`location` | `varchar`<br> The URL of the source instance at the time it was added to the database. |

```
# schema
# (
#   id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
#   parent_entity VARCHAR,
#   parent_stream VARCHAR,
#   instance_name VARCHAR,
#   publication_date DATETIME,
#   location VARCHAR
# );

# Example record
# {
# 	"id" : "1",
# 	"parent_entity" : "Complex",
# 	"parent_stream" : "Best New Music This Week",
# 	"instance_name" : "Brockhampton, Vince Staples, Lana Del Rey, and More",
# 	"publication_date" : "2019-08-23 00:00:00.000000",
# 	"location" : "https://www.complex.com/music/best-new-music-this-week-brockhampton-vince-staples-lana-del-rey"
# }
```


### Song Data
The `song` model describes a unique song added to the database.

song ||
--- | --- |
`id` | `integer`<br> The unique `id` for the song. |
`title` | `varchar`<br> The title of the song. |
`artist_name` | `varchar`<br> The name of the artist or artists, prior to artist deduplication or cleanup. |
`video_id` | `varchar`<br> The YouTube video ID. |

```
# Schema
# (
#   id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
#   title VARCHAR,
#   artist_name VARCHAR,
#   video_id VARCHAR
# );

# Example record
# {
# 	"id" : "1",
# 	"title" : "St. Percy",
# 	"artist_name" : "Brockhampton",
# 	"video_id" : "rp-I-YGg6Hs"
# }
```


### Source-Song Join Table
The `source_song` table allows many-to-many relationships between sources and songs.

source_song ||
--- | --- |
`id` | `integer`<br> The unique `id` for the source-song reference. |
`capture_date` | `datetime`<br> The date the song instance was added to the database. |
`source_id` | `integer`<br> A reference to the `source` the song was added from. |
`song_id` | `integer`<br> A reference to the unique `song` added. |

```
# Schema
# (
#    id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
#    capture_date DATETIME,
#    source_id INTEGER,
#    song_id INTEGER,
#    FOREIGN KEY(source_id) REFERENCES source (id),
#    FOREIGN KEY(song_id) REFERENCES song (id)
# );

# Example record
# {
# 	"id" : 1,
# 	"capture_date" : "2020-05-04 21:25:11.000000",
# 	"source_id" : 1,
# 	"song_id" : 1,
# }
```


### Multi-song Videos
The `multisong_vid` table tracks `video_ids` that are valid duplicates.

multisong_vid ||
--- | --- |
`id` | `integer`<br> The unique `id` for the valid match. |
`video_id` | `varchar`<br> The YouTube video ID for the multi-song video. The count of unique `video_ids` in this table gives the valid duplicate count for each `video_id`. |
`song_id` | `integer`<br> The unique `id` for each song that corresponds to a multi-song video. |

```
# Schema
# (
#   id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
#   video_id VARCHAR,
#   song_id VARCHAR,
#   FOREIGN KEY(video_id) REFERENCES song (video_id)
#   FOREIGN KEY(song_id) REFERENCES song (id)
# );

# Example record
```


### Manual Video Metadata
The `video_metadata` model describes metadata that needs some help from a human to fill in.

video_metadata ||
--- | --- |
`song_id` | `integer`<br> A reference to the song (not the `video_id`, since it's possible for one video to contain multiple songs). |
`has_video` | `enum`<br> Indicates whether the `video_id` has a decent quality music video ("Y"), or a static image ("N"), or is a temporary or lyric video, etc ("T"). |
`check_back` | `bool`<br> Flags a video to check back later for a possible update to the `video_id` and `has_video`. For example, if a lyric video seems likely to be replaced soon by an official video. |
`shelf_life` | `bool`<br> Indicates if the song is temporally bounded to a specific event, and not just to the stylistic qualities of its era. |
`start_time` | `time`<br> The time one second before the second when music begins (to trim non-music intros). This is input as displayed on YouTube, and converted to seconds in the player. |
`end_time` | `time`<br> The time one second after the second when the song ends (to trim non-music outros). This is input as displayed on YouTube, and converted to seconds in the player. |
`release_year` | `year`<br> The year the song was first released, which may be different from the year it was published to YouTube. Can take a little research, especially for older songs. |

```
# Schema
# (
#   song_id INTEGER,
#   has_video VARCHAR,
#   check_back BOOLEAN,
#   shelf_life BOOLEAN,
#   start_time TIME,
#   end_time TIME,
#   release_year INTEGER,
#   FOREIGN KEY(song_id) REFERENCES song (id)
# );

# Example record
```


### Video Zoom
The `video_zoom` model describes data needed to scale the active video content (inside letterboxing) to fill the browser window.

video_zoom ||
--- | --- |
`song_id` | `integer`<br> A reference to the song (not the `video_id`, since it's possible for one video to contain multiple songs). |
`video_width` | `integer`<br> The pixel width of active video content within the video file (inside letterboxing), or a pixel width that yields the correct aspect ratio relative to `video_height`. |
`video_height` | `integer`<br> The pixel height of active video content within the video file (inside letterboxing), or a pixel height that yields the correct aspect ratio relative to `video_width`. |
`x_offset` | `integer`<br> A pixel value based on `video_width` to correct active video content that is not centered on the x axis (uncommon).
`y_offset` | `integer`<br> A pixel value based on `video_height` to correct active video content that is not centered on the y axis (uncommon).

```
# Schema

# Example record
```


### Automatic Video Metadata
The `yt_data_onetime` model describes video metadata updated once from the YouTube Data API.

yt_data_onetime ||
--- | --- |
`video_id` | `varchar`<br> The YouTube video ID. Used to reference the song(s) that use this video. |
`dl` | `bool`<br> Indicates whether there is a copy of the video file on the Shapes server. |
`yt_publication_date` | `datetime`<br> The date the video was published to YouTube. This often (but not always) indicates a song's release date. |
`duration` | `varchar`<br> The length of the video represented as a Bergsonian... wait, no, as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Durations) duration. |
`iframe_width` | `integer`<br> YouTube's recommended iframe width. This is the closest we can get to YouTube's file `widthPixels` and `aspectRatio`, which are only visible to the video owner. |
`iframe_height` | `integer`<br> YouTube's recommended iframe height in pixels. This is the closest we can get to YouTube's file `heightPixels` and `aspectRatio`, which are only visible to the video owner. |
`file_width` | `integer`<br> The pixel width of the downloaded video file. This can be used to calculate the aspect ratio of the file, which does not necessarily correspond to the aspect ratio of the active video content (inside letterboxing). |
`file_height` | `integer`<br> The pixel height of the downloaded video file. This can be used to calculate the aspect ratio of the file, which does not necessarily correspond to the aspect ratio of the active video content (inside letterboxing). |

```
# Schema

# Example record
```


The `yt_data_recurring` model describes video metadata updated regularly from the YouTube Data API.

yt_data_recurring ||
--- | --- |
`video_id` | `varchar`<br> The YouTube video ID. Used to reference the song(s) that use this video. |
`yt_exists` | `bool`<br> Indicates if the video is currently available on YouTube (not removed). |
`yt_view_count` | `integer`<br> The number of YouTube views. |
`yt_regions_allowed` | `enum`<br> Regions where the video is explicitly allowed. A video is available in your local region if: a) your region appears in this list; or b) your region does *not* appear in `yt_regions_blocked`; or c) your region does not appear in either list. |
`yt_regions_blocked` | `enum`<br> Regions where the video is explicitly blocked. A video is available in your local region if: a) your region does *not* appear in this list; or b) your region appears in `yt_regions_allowed`; or c) your region does not appear in either list. |
`yt_age_restricted` | `bool`<br> Indicates videos where YouTube displays the alert: "This video may be inappropriate for some users." and requires user agreement. |

```
# Schema

# Example record
```


### Key Level Context  
The `key_context` model interprets [`key_context`](#user-key-level-context) user data. References `song_id` rather than `session_id`.

```
# Schema

# Example record
```


### Chord Level Context  
The `chord_context` model interprets [`chord_context`](#user-chord-level-context) user data. References `song_id` rather than `session_id`.

```
# Schema

# Example record
```


### Song Preferences
The `preference` model describes data for determining which songs to include or feature. Informed by [`favorite`](#user-song-favorites) and [`rating`](#user-song-rating) data in `shapes_experiments.sqlite`.

preference ||
--- | --- |
`song_id` | `integer`<br> A reference to the song (not the `video_id`, since it's possible for one video to contain multiple songs). |
`favorite` | `bool`<br> Indicates if the song is a Shapes featured song. |
`explicit` | `bool`<br> Indicates if the song contains explicit content. |
`kids` | `bool`<br> Indicates if the song is particularly well-suited for kids.

```
# Schema

# Example record
```


### Audio Data
The `audio` model describes audio attributes of the song relevant to player and instrument settings.

audio ||
--- | --- |
`song_id` | `integer`<br> A reference to the song (not the `video_id`, since it's possible for one video to contain multiple songs). |
`tuning` | `integer`<br> The frequency to which the note "La" is assigned (standard 440).
`volume` | `integer`<br> The volume/gain profile for the song.
`timbre` | `varchar`<br> The timbral profile for the song. Something like an EchoNest valence. Looking forward to figuring out exactly what this means, but will be related to choosing instrument timbres that sound good with the song.

```
# Schema

# Example record
```


### Default Instrument Settings
The `instrument` model describes settings for a default browser instrument yet to be built.

instrument ||
--- | --- |
`song_id` | `integer`<br> A reference to the song (not the `video_id`, since it's possible for one video to contain multiple songs). |
`tuning_offset` | `integer`<br> A frequency offset from `audio.tuning`. |
`temperament` | `varchar`<br> The tuning system to use (default is *Equal Temperament*). Calculates from `anchor` note when necessary. Also potentially describes the tuning system used in the song. |
`transposition` | `integer`<br> A semitone offset from the `audio.tuning` note ("La"). |
`preset` | `varchar`<br> The default timbral preset for the song. Potentially related to the song's timbral profile described by `audio.timbre`. |
`volume` | `integer`<br> The default volume setting for the instrument, based on the `preset`. Ideally, volume is ignostic to the choice of `preset`. Potentially related to the song's volume profile described by `audio.volume`. |

```
# Schema

# Example record
```


### Original iPad App Instrument Settings
The `ipad_instrument` model describes settings for the sampler instrument included in the original Shapes iPad App from 2012-2013.

ipad_instrument ||
--- | --- |
`song_id` | `type`<br> A reference to the song (not the `video_id`, since it's possible for one video to contain multiple songs). |
`preset` | `varchar`<br> The default of five sampler instrument sounds in the original app. May reflect an overall timbral profile for the song. |
`volume` | `type`<br> The default volume setting for the sampler, based on the `preset`. May reflect an overall volume/gain profile for the song. |

```
# Schema

# Example record
```


---
## Shapes User and Experiment Data  
This is the data generated by user-facing Shapes applications.


### Session Data
The `session` model identifies which song was played, when it was played, and the application and user context for the play. A session corresponds to a single song play.

session ||
--- | --- |
`id` | `integer`<br> The unique `id` for the session. |
`song_id` | `integer`<br> A reference to the song (not the `video_id`, since it's possible for one video to contain multiple songs). |
`start` | `datetime`<br> The UTC timestamp when the player loads a new song.  |
`end` | `datetime`<br> The UTC timestamp when the session ends. This may be a) when the user skips to a new song, b) when the song reaches its specified `end_time`, or c) when the application quits. |
`app` | `varchar`<br> The name of the application (or page view, etc.) that generated the session. |
`user` | `varchar`<br> A unique username chosen by the user. |

```
# Schema

# Example record
```


### User Key Level Context
The `key_context` model contains user data to inform the `key_context` table in `shapes.sqlite`.

key_context ||
--- | --- |
`session_id` | `integer`<br> A reference to the song session. |
`single_shape` | `enum`<br> Indicates if the song matches convincingly with a single shape, and gives the best match. Otherwise, indicates that the song is a `MULTI` (multi-shape) song. |
`single_anchor` | `enum`<br> Indicates if the song matches convincingly with a single anchor, and gives the best match. Otherwise, indicates that the song is a `MULTI` (multi-anchor) song. |
`multi_shapes` | `object`<br> Indicates key-level shape changes within the song. Each change defines:  <br>- the `timestamp` within the video when the change takes place, and <br>- the `shape` that corresponds to the `timestamp`. |
`multi_anchors` | `object`<br> Indicates key-level anchor changes within the song. Each change defines:  <br>- the `timestamp` within the video when the change takes place, and <br>- the `anchor` that corresponds to the `timestamp`. |

```
# Schema

# Example record
```


### User Chord Level Context
The `chord_context` model contains user data to inform the `chord_context` table in `shapes.sqlite`.

chord_context ||
--- | --- |
`session_id` | `integer`<br> A reference to the song session. |
`bass_notes` | `object`<br> Indicates chord-level bass note changes within the song. Each change defines:  <br>- the `timestamp` within the video when the change takes place, and <br>- the `bass_note` that corresponds to the `timestamp`. |
`shapes` | `object`<br> Indicates chord-level shape changes within the song, if different from key-level shapes. Each shape change defines:  <br>- the `timestamp` within the video when the change takes place, and <br>- the `shape` that corresponds to the `timestamp`. |
`root_notes` | `object`<br> Indicates chord-level root note changes within the song, if different from `bass_notes`. This introduces the idea of "function." Each change defines:  <br>- the `timestamp` within the video when the change takes place, and <br>- the `root_note` that corresponds to the `timestamp`. |

```
# Schema

# Example record
```


### User Comments  
The `comment` model contains user comments and interaction notes.

comment ||
--- | --- |
`session_id` | `integer`<br> A reference to the song session. |
`comment` | `varchar`<br> The text of the comment. |
`video_time` | `time`<br> The video timestamp that corresponds to the comment. |
`utc_time` | `datetime`<br> The UTC timestamp that corresponds to the comment. |

```
# Schema

# Example record
```


### User Song Favorites
The `favorite` model contains data indicating user song favorites. The data informs the `preference` model in `shapes.sqlite`.

favorite ||
--- | --- |
`session_id` | `integer`<br> A reference to the song session. |
`heart` | `bool`<br> Indicates if the user has selected the song as a favorite. |
`select` | `bool`<br> The user has loaded the song intentionally (such as by choosing "play previous"). |
`skip_time` | `time`<br> Indicates if the user skipped the song, and provides a timestamp within the video. |

```
# Schema

# Example record
```


### User Song Rating
The `rating` model describes data indicating user opinions about song rating. The data informs the `preference` model in `shapes.sqlite`.

rating ||
--- | --- |
`session_id` | `integer`<br> A reference to the song session. |
`explicit` | `bool`<br> The user indicates that the song contains explicit content. |
`kids` | `bool`<br> The user indicates that the song is well-suited for kids. |

```
# Schema

# Example record
```


### Event Data
The `event` model describes instrument (MIDI) notes or durationless (timestamp) events, such as pulse markers.

event ||
--- | --- |
`session_id` | `integer`<br> A reference to the song session. |
`start_video` | `integer`<br> The video timestamp that corresponds to the event start. |
`start_utc` | `integer`<br> The UTC timestamp that corresponds to the event start. |
`end_video` | `integer`<br> The video timestamp that corresponds to the event end. |
`end_utc` | `integer`<br> The UTC timestamp that corresponds to the event end. |
`midi_note` | `integer`<br> The MIDI note number of the event. |
`velocity` | `integer`<br> The MIDI velocity of the event. |

```
# Schema

# Example record
```


---
## Application Tasks  


### Scrape Songs

- Done manually using the [Song-Scraper](https://github.com/davidforrest/Song-Scraper) app.  
- Creates `source` and `song` documents.
- Not all `video_id` fields will be populated
- Inevitably adds duplicate songs.


### Find and Remove Duplicate Songs

- Based on fuzzy matching of `song.title` and `song.artist_name` (before manually adding `song.video_id`)
- Possibly also consider `song.video_id` (however, it is possible for two different songs to exist within the same `video_id`)


### Add YouTube Video IDs

- displays only songs where `song.video_id` is blank or NULL
- manually add & update `song.video_id`
- check if newly-added `video_id` already exists, and if so, display matching song record(s)


### Crawl YouTube Metadata

- regularly and automatically update YouTube data that's subject to change:
    - `yt_exists`
    - `yt_view_count`
    - `yt_regions_allowed`
    - `yt_regions_blocked`
- ok to overwrite prior values rather than tracking how this data changes over time? that seems a bit outside the focus of this project.


### Retrieve One-Time YouTube Metadata

- automatically populate the YouTube data that's unlikely to change:
    - `yt_age_restricted` (could this change?)
    - `yt_publication_date`
    - `duration`
    - `iframe_width`
    - `iframe_height`


### Download Music Video Files to the server

- only download songs that exist according to recent YouTube Metadata
- using [youtube-dl](https://github.com/ytdl-org/youtube-dl)
- had been using a .txt file listing all `video_id` to be downloaded, with the following quality settings:  
```
youtube-dl -a song_list.txt -f 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best' --id
```
- update `dl` field
- update `dl_width` and `dl_height` fields in Automatic Video Metadata
- check downloaded files against unique `video_id`s (to replace videos, for example, that were removed or blocked before we downloaded them)


### Input Manual Video Metadata

- the manual updates that aren't music-related:
    - `has_video`
    - `start_time`
    - `end_time`
    - `release_year`
- also includes video zoom until that can be automated


### Play Videos as fullscreen background

- Filter videos for:
    - `video_id` is defined
    - available on YouTube in your region
    - `has_video`
    - published or added within a date range
    - etc.

Let's think about video zoom for a moment. What we're really doing is:
- laying a div over the video that matches the active content size  
- adjusting the video on the x & y axis beneath that div if necessary  
- scaling the div (and its contents) to fill the browser window (based on the shortest side?)


### Play a Browser Instrument over Video Background

- set default settings
- collect user settings to inform default settings (manually set tuning, instrument timbre, etc.)
- potentially use [websynths.com](https://websynths.com/) as inspiration?
- potentially make use of the default instrument and volume settings from the original iPad app?


### Automatically Analyze Tuning and Key Context

- Klaus [prototyped](https://gitlab.com/vltmrkls/shapes-detection) a shape detection that could (potentially) crawl over the downloaded video files.
- [tONaRT](http://www.zplane.de/index.php?page=description-tonart) and others can detect the tuning and Major/minor key, which a human could verify.
- ideally this kind of analysis would happen between music start and end times, or other time ranges defined elsewhere in the data
