## Overview  

This document organizes the Shapes data fields that exist so far, sketches some data fields that don't yet exist, and lists various application tasks to populate and use those data fields.

The data is organized into two separate databases. In general, `shapes.sqlite` contains the data required by user-facing Shapes applications, and `shapes_experiments.sqlite` contains the data generated by those applications.

Some data in `shapes.sqlite` is subjective or interpretive, and so is informed by analysis of the data in `shapes_experiments.sqlite`.

**[Shapes Application Data](#shapes-application-data)**  
`shapes.sqlite`
- [Source Data](#source-data)  
- [Initial Song Data](#initial-song-data)  
- [Automatic Video Metadata](#automatic-video-metadata)  
- [Manual Video Metadata](#manual-video-metadata)  
- [Video Zoom](#video-zoom)  
- [Audio Data](#audio-data)  
- [Default Instrument Settings](#default-instrument-settings)  
- [Original iPad App Instrument Settings](#original-ipad-app-instrument-settings)  
- ...

**[Shapes User and Experiment Data](#shapes-user-and-experiment-data)**  
`shapes_experiments.sqlite`
- [Session Data](#session-data)  
- [Automatic Tuning and Key Analysis](#automatic-tuning-and-key-analysis)
- ...

**[Application Tasks](#application-tasks)**
- [Scrape Songs](#scrape-songs)  
- [Find and Remove Duplicate Songs](#find-and-remove-duplicate-songs)  
- [Add YouTube Video IDs](#add-youtube-video-ids)  
- [Crawl YouTube Metadata](#crawl-youtube-metadata)  
- [Retrieve One-Time YouTube Metadata](#retrieve-one-time-youtube-metadata)  
- [Download Music Video Files to the server](#download-music-video-files-to-the-server)
- [Input Manual Video Metadata](#input-manual-video-metadata)
- [Play Videos as fullscreen background](#play-videos-as-fullscreen-background)
- [Automatically Analyze Tuning and Key](#automatically-analyze-tuning-and-key)
- [Play a Browser Instrument over Video Background](#play-a-browser-instrument-over-video-background)
- ...
- [Other tasks to consider](#other-tasks-to-consider)



---
## Shapes Application Data
This is the data required by user-facing Shapes applications. Much of


### Source Data  
The `source` schema describes the source (e.g. a chart, playlist, article, etc.) from which songs were added to the database.

source ||
--- | --- |
`id` | `integer`<br> The unique `id` for the source. |
`parent_entity` | `varchar`<br> The organization, publication, institution, etc. from which the source originated. |
`parent_stream` | `varchar`<br> The recurring series, feed, channel, etc. where the source was published. |
`instance_name` | `varchar`<br> The published instance of the source. |
`publication_date` | `datetime`<br> The publication date of the source. |
`location` | `varchar`<br> The URL of the source instance at the time it was added to the database. |

```
# Example of a source record
# {
# 	"id" : "1",
# 	"parent_entity" : "Complex",
# 	"parent_stream" : "Best New Music This Week",
# 	"instance_name" : "Brockhampton, Vince Staples, Lana Del Rey, and More",
# 	"publication_date" : "2019-08-23 00:00:00.000000",
# 	"location" : "https://www.complex.com/music/best-new-music-this-week-brockhampton-vince-staples-lana-del-rey"
# }
```

### Initial Song Data
The `song` schema describes basic data for adding a new song to the database.

song ||
--- | --- |
`id` | `integer`<br> The unique `id` for the song. |
`capture_date` | `datetime`<br> The date the song was added to the database. |
`source_id` | `integer`<br> A reference to the `source` the song was added from. |
`title` | `varchar`<br> The title of the song. |
`artist_name` | `varchar`<br> The name of the artist or artists listed in the source, prior to deduplication or cleanup. |
`video_id` | `varchar`<br> The YouTube video ID. |

```
# Example of a song record
# {
# 	"id" : "1",
# 	"capture_date" : "2020-05-04 21:25:11.000000",
# 	"capture_source" : "1",
# 	"title" : "St. Percy",
# 	"artist_name" : "Brockhampton",
# 	"video_id" : "rp-I-YGg6Hs"
# }
```

### Automatic Video Metadata
The `yt_metadata` schema describes video metadata updated automatically from the YouTube Data API and youtube-dl.

yt_metadata ||
--- | --- |
`video_id` | `varchar`<br> The YouTube video ID. Used to reference the song(s) that use this video. |
`dl` | `boolean`<br> Indicates whether there is a downloaded copy of the video file on the Shapes server (copyright lawyers avert your eyes). |
`yt_exists` | `boolean`<br> Indicates if the video is currently available on YouTube (not removed). Updated regularly. |
`yt_view_count` | `integer`<br> The number of YouTube views, updated regularly. |
`yt_regions_allowed` | `enum`<br> Regions where the video is explicitly allowed, updated regularly. A video is available in your local region if: a) your region appears in this list; or b) your region does *not* appear in `yt_regions_blocked`; or c) your region does not appear in either list. |
`yt_regions_blocked` | `enum`<br> Regions where the video is explicitly blocked, updated regularly. A video is available in your local region if: a) your region does *not* appear in this list; or b) your region appears in `yt_regions_allowed`; or c) your region does not appear in either list. |
`yt_age_restricted` | `boolean`<br> Indicates videos where YouTube displays the alert: "This video may be inappropriate for some users." and requires user agreement. |
`yt_publication_date` | `datetime`<br> The date the video was published to YouTube. This often (but not always) indicates a song's release date. |
`duration` | `varchar`<br> The length of the video represented as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Durations) duration. |
`iframe_width` | `integer`<br> YouTube's recommended iframe width. This is the closest we can get to YouTube's file `widthPixels` and `aspectRatio`, which are only visible to the video owner. |
`iframe_height` | `integer`<br> YouTube's recommended iframe height in pixels. This is the closest we can get to YouTube's file `heightPixels` and `aspectRatio`, which are only visible to the video owner. |
`file_width` | `integer`<br> The pixel width of the downloaded video file. This can be used to calculate the aspect ratio of the file, which does not necessarily correspond to the aspect ratio of the active video content (inside letterboxing). |
`file_height` | `integer`<br> The pixel height of the downloaded video file. This can be used to calculate the aspect ratio of the file, which does not necessarily correspond to the aspect ratio of the active video content (inside letterboxing). |

```
# Example of a yt_metadata record
```


### Manual Video Metadata
The `video_metadata` schema describes video metadata that requires some help from a human to determine.

video_metadata ||
--- | --- |
`song_id` | `integer`<br> A reference to the song (not the `video_id`, since it's possible for one video to contain multiple songs). |
`has_video` | `enum`<br> Indicates whether the `video_id` has a decent quality music video ("Y"), or a static image ("N"), or is a temporary or lyric video, etc ("T"). |
`start_time` | `time`<br> The time one second before the second when music begins (to trim non-music intros). This is input as displayed on YouTube, and converted to seconds in the player. |
`end_time` | `time`<br> The time one second after the second when the song ends (to trim non-music outros). This is input as displayed on YouTube, and converted to seconds in the player. |
`release_year` | `year`<br> The year the song was first released, which may be different from the year it was published to YouTube. Can take a little research, especially for older songs. |

```
# Example of a video_metadata record
```


### Video Zoom
The `video_zoom` schema describes data needed to scale the active video content (inside letterboxing) to fill the browser window.

video_zoom ||
--- | --- |
`song_id` | `integer`<br> A reference to the song (not the `video_id`, since it's possible for one video to contain multiple songs). |
`video_width` | `integer`<br> The pixel width of active video content within the video file (inside letterboxing), or a pixel width that yields the correct aspect ratio relative to `video_height`. |
`video_height` | `integer`<br> The pixel height of active video content within the video file (inside letterboxing), or a pixel height that yields the correct aspect ratio relative to `video_width`. |
`x_offset` | `integer`<br> A pixel value based on `video_width` to correct active video content that is not centered on the x axis (uncommon).
`y_offset` | `integer`<br> A pixel value based on `video_height` to correct active video content that is not centered on the y axis (uncommon).

```
# Example of a video_zoom record
```

### Audio Data
The `audio` schema describes audio attributes of the song relevant to player and instrument settings.

audio ||
--- | --- |
`song_id` | `integer`<br> A reference to the song (not the `video_id`, since it's possible for one video to contain multiple songs). |
`tuning` | `integer`<br> The frequency to which the note "La" is assigned (standard 440).
`volume` | `integer`<br> The volume/gain profile for the song.
`timbre` | `varchar`<br> The timbral profile for the song. Something like an EchoNest valence. Looking forward to figuring out exactly what this means, but will be related to choosing instrument timbres that sound good with the song.

```
# Example of an audio record
```


### Default Instrument Settings
The `instrument` schema describes settings for a default browser instrument yet to be built.

instrument ||
--- | --- |
`song_id` | `integer`<br> A reference to the song (not the `video_id`, since it's possible for one video to contain multiple songs). |
`tuning_offset` | `integer`<br> A frequency offset from `audio.tuning`. |
`temperament` | `varchar`<br> The tuning system to use (default is *Equal Temperament*). Calculates from `anchor` note when necessary. Also potentially describes the tuning system used in the song. |
`transposition` | `integer`<br> A semitone offset from the `audio.tuning` note ("La"). |
`preset` | `varchar`<br> The default timbral preset for the song. Potentially related to the song's timbral profile described by `audio.timbre`. |
`volume` | `integer`<br> The default volume setting for the instrument, based on the `preset`. Ideally, volume is ignostic to the choice of `preset`. Potentially related to the song's volume profile described by `audio.volume`. |

```
# Example of an instrument record
```


### Original iPad App Instrument Settings
The `ipad_instrument` schema describes settings for the sampler instrument included in the original Shapes iPad App from 2012-2013.

ipad_instrument ||
--- | --- |
`song_id` | `type`<br> A reference to the song (not the `video_id`, since it's possible for one video to contain multiple songs). |
`preset` | `varchar`<br> The default of five sampler instrument sounds in the original app. May reflect an overall timbral profile for the song. |
`volume` | `type`<br> The default volume setting for the sampler, based on the `preset`. May reflect an overall volume/gain profile for the song. |

```
# Example of an ipad_instrument record
```


---
## Shapes User and Experiment Data  


## Session Data
The `session` schema identifies the song, temporal, application, and user context within which data is generated. Each session corresponds to a single song play.

session ||
--- | --- |
`id` | `integer`<br> The unique `id` for the session. |
`song_id` | `integer`<br> A reference to the song (not the `video_id`, since it's possible for one video to contain multiple songs). |
`start` | `datetime`<br> The timestamp when the player loads a new song.  |
`end` | `datetime`<br> The timestamp when the session ends. This may be a) when the user skips to a new song, b) when the song reaches its specified `end_time` and advances automatically, or c) when the application quits. |
`app` | `varchar`<br> The name of the application that generated the session. |
`user` | `varchar`<br> A unique username chosen by the user. |

```
# Example of a session record
```

[Left Off Here]

**playlist data fields remaining:**

- user & one-off song sources
  - from (one-off)
- user shape & anchor
  - MDF S/A
- does it work as a single shape?
  - single_shape (or MULTI)
  - single_anchor (or MULTI)
- anything more complicated than single shape needs theory-modeling:
  - CAT (list complicated song categories)
  - songCat (method categories)
  - catNotes (notes on method categories)
- user notes
  - notes(interaction)
    - mine
    - MDFs / user
- ethics
  - ok4kids (bool)
  - explicit (bool)
- hearts
  - shapesFavs (user heart: me/admin)
  - interesting (my favs? vs shapes featured?)
  - (songs skipped a lot or played a lot)
- copyright/similarity
  - tag (rap/hum)
  - HUMset
  - notes(hum)
- to add:
  - pulse (& other attributes in the HUM tool)
- could be derived
  - include(app)
  - orgBlocks (playlisting process)


### Automatic Tuning and Key Analysis
This would be based on one particular detection algorithm, for example [TONART](https://licensing.zplane.de/technology#tonart). Would need to differentiate values generated by a different algorithm, or store them in a separate table.

Properties ||
--- | --- |
`key_center` | `varchar`<br> The tonic, translated to an independent solfege syllable. Potentially useful when considering "anchor note," because this seems to influence the algorithm's conception of "key signature" |
`mode` | `varchar`<br> The mode (Major or minor). Potentially useful when compared to a looser conception of key center + key signature  |





```
# Example of an event record
# {
# 	"_id" : ObjectId("5bf84f367356e263e1cc8654"),
# 	"sessionId" : "3wjobjq9jouea1u7",
# 	"eventClockTimeISO" : "2018-11-23T19:04:09.551Z",
# 	"eventVideoTimeMs" : "932",
# 	"__v" : 0
# }
```


---
## Application Tasks  


### Scrape Songs

- Done manually using [Chart Scraper]() app.  
- Creates `source` and `song` documents.
- Not all `video_id` fields will be populated
- Duplicate songs will be scraped


### Find and Remove Duplicate Songs

- Based on fuzzy matching of `song.title` and `song.artist_name` (before manually adding `song.video_id`)
- Possibly also consider `song.video_id` (however, it is possible for two different songs to exist within the same `video_id`)


### Add YouTube Video IDs

- displays only songs where `song.video_id` is empty
- manually add & update `song.video_id`
- check if newly-added `video_id` already exists, and if so, display matching song document(s)


### Crawl YouTube Metadata

- regularly and automatically update YouTube data that's subject to change:
    - `yt_exists`
    - `yt_view_count`
    - `yt_regions_allowed`
    - `yt_regions_blocked`
- do we want to store prior data to track how it changes over time?


### Retrieve One-Time YouTube Metadata

- automatically populate the YouTube data that's unlikely to change:
    - `yt_age_restricted` (could this change?)
    - `yt_publication_date`
    - `duration`
    - `iframe_width`
    - `iframe_height`


### Download Music Video Files to the server

- only download songs that exist according to recent YouTube Metadata
- using [youtube-dl](https://github.com/ytdl-org/youtube-dl)
- had been using a file listing all `video_id` to be downloaded, with the following quality settings:  
```
youtube-dl -a song_list.txt -f 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best' --id
```
- update `dl` field
- update `dl_width` and `dl_height` fields in Automatic Video Metadata
- check downloaded files against unique `video_id`s (to replace videos, for example, that were removed or blocked before we downloaded them)


### Input Manual Video Metadata

- the manual updates that aren't music-related:
    - `has_video`
    - `start_time`
    - `end_time`
    - `release_year`
- also includes video zoom until that can be automated


### Play Videos as fullscreen background

- Filter videos for:
    - `video_id` is defined
    - available on YouTube in your region
    - `has_video`
    - published or added within a date range
    - etc.

Let's think about video zoom for a moment. What we're really doing is:
- laying a div over the video that matches the active content size  
- adjusting the video on the x & y axis beneath that div if necessary  
- scaling the div (and its contents) to fill the browser window (based on the shortest side?)

But maybe it's impractical to require the actual pixel width. It's something we need to calculate manually in the browser.


### Automatically Analyze Tuning and Key

- [tONaRT](http://www.zplane.de/index.php?page=description-tonart) and others can detect the tuning and Major/minor key, which a human could verify.
- ideally this analysis would happen between music start and end times, or other time ranges defined elsewhere in the data


### Play a Browser Instrument over Video Background

- set default settings
- collect user settings to inform default settings (manually set tuning, instrument timbre, etc.)
- potentially use [websynths.com](https://websynths.com/) as inspiration?
- potentially make use of the default instrument and volume settings from the original iPad app?


### Other Tasks to consider  

- User added song & source  
- Compare user shape and anchor (like MDF) with "correct" shape and anchor
- "correctness" value for shape, anchor, etc based on user and automatic detection data
